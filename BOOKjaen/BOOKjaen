반복문
반복문 주어진 조건에 의해 특정 코드 블록을 반복적으로 실행할 수 있게 해주는 구문입니다. 프로그래밍에서 코드 블록의 반복을 루프(Loop)라고 부르고 반복되는 횟수를 루프 횟수라고 부르는데. 스위프트에서 제공하는 반복문은 루프 횟수가 정해져 있는지를 기준으로 두 가지 방식으로 나눌 수 있습니다.
* For 반복문
* While 반복문
For 반복문은 in 키워드와 함께 사용되어 정해진 횟수만큼 주어진 코드 블록을 반복해서 실행합니다. for ~ in{...} 형식으로 사용되죠. 스위프트 2.0 버전까지는 C스타일의 for 구문(초기값, 조건식, 증감값으로 처리되는)도 사용할 수 있었지만, 3.0 버전 이후로 이 스타일의 구문은 더 이상 지원되지 않습니다. 이제 스위프트에서 for 반복문은 for ~ in 구문 뿐입니다. 정해진 횟수만큼만 반복하는 For 반복문과 달리, While 반복문은 주어진 조건이 false가 될 때 까지 계속해서 구문을 반복 실행하는 특성이 있습니다. 미리 반복 횟수를 정하지 않아도 된다는 장점이 있디 때문에 반복 횟수를 예측하기 어려운 조건의 반복문에서 주로 사용됩니다.
While 반복문은 while 구문과 repeat~while 구문으로 나누어지는, while 구문은 매번 루프를 시작할 때 조건식을 평가하여 루프를 돌지 말지 결정하지만 repeat~while 구문은 루프를 완료할 때 마다 조건을 평가하여 다음 루프 실행 여부를 결정합니다. 즉 일단 주어진 코드 블록을 실행한 다음에 다시 한 번 루프를 실행할지 말지를 조건식을 통해 평가하는다는 겁니다. 이처럼 조건식을 평가하는 시점의 차이 때문에 두 구문은 실행 결과에도 약간의 차이가 생기는데, 예를 들어 주어진 조건이 처음부터 거짓일 때 while 구문은 한 번도 실행되지 않고, 그대로 종료하지만, repeat~while은 조건이 거짓이라도 최소 한 번은 실행됩니다.
정리해보면, for 반복문은 횟수에 의한 반복이며 While 반복문은 조건에 의한 반복이라고 할 수 있습니다.
빈복문 내에서 흐름을 제어하고자 할 때에는 break 구문과 continue 구문이 사용됩니다. 이 구문들은 제어전달문으로서, 적절한 시점에 사용되어 코드 블록의 실행 흐름을 옮겨주는 역할을 합니다.
4.1.1 for~in 구문
스위프트에서 일정 횟수만큼 특정 구문을 반복하고자 할 때에는 for~in 구문을 사용합니다. 먼저 구문의 형식부터 살펴봅시다.
```for <루프 상수> in <순회 대상> {
	<실행할 구문>
}```
기본적으로 이 구문을 실행하기 위해서는 세 개의 항목이 필요합니다. 루프 상수와 순회 대상, 그리고 실행할 구문이죠. for~in 구문에서 가자아 중요한 것을 순회 대상입니다. 순회 대상은 주로 순점능 가지는 집단 자료형이나 for~in 구문에서 가장 중요한 것은 순회 대상입니다. 순회 대상은 주로 순번을 가지는 집단 자료형이나 또는 범위를 가지는 데이터 등이 사용되는데, 이 대상의 길이나 포함하고 있는 아이템의 개수 만큼 구문이 반복 수행됩니다. 순회 대상으로 사용할 수 있는 데이터 타입에는 다음과 같은 것들이 있습니다.
* 배열(Array)
* 딕셔너리(Dictionay)
* 집합(Set)
* 범위 데이터
* 문자열(String)
이 중에서 배열이나 딕셔너리 긜고 집합은 아직 학습하기 전이미나, 범위 대이터나 문자열은 앞에서 배운 내용입니다. 범위 데이터는 범위 연산자에 의해 규칙적인 간격으로 나열되 정수으 모음이며 String은 Character 차입의 데이터들이 모여 이루는 집단적 성격의 데이터입니다 아직 배우지 않은 배열과 딕셔너리, 그리고 딥합에 대해 간략하게 설명하자면 단일 데이터가 아닌 유사한 속성의 데이터 여러 개가 모ㅕ서 하나의 덩어리를 이루는 집단 자료형 (Collective Types)이라고 보면 됩니다. 여러 데이터를 포함하고 있다는 의미에서 컨테이너 타이빙라고 불리기도 합니다. 집단 자료형은 다음 장에서 자세히 다루게 됩니다.
for ~ in 구문을 이루는 마지막 요소인 실행 구문은 {} 사이에 작성됩니다. 중괄호 {}로 둘러싸인 영역을 보통 코드 블록(Code Block)이라고 부르는데, 다른 구문과 영역을 나누는 용도로 사용됩니다. 일종의 울타리라는 거죠. 여기서는 for 루프에 의해 반복 실행될 구문의 범위를 표시하는 역할을 합니다. 다시 말해, for~in 구문의 {} 블록 내에 작성된 구문만 반복해서 실행된다는 뜻입니다.
전체적인 for 반복문의 실행 구조는 피스톨(Pistol)이라고도 불리는 권총의 장전 구조와 흡사합니다. 권총의 탄창에는 여러 발의 탄화이 들어가는데, 이렇게 탄환이 채워진 탄창은 권총에 장전되어 연속해서 발사됩니다. 탄창에 채워진 탄환이 모두 소비될 때까지 말이죠 이 대 탄창은 for 반복문에서의 순회 대상에 해당됩닏. 순회 대상은 내부에 여러 개의 아이템을 순서대로 장착하고 있거든요. 탄창에 들어간 탄환의 수만큼 연속해서 방아쇠를 당길 수 있는 것처럼 for~in 구문에서는 순회 대상이 포함하고 있는 아이템의 개수만큼 실행 구문이 반복됩니다.
권총에서 방아쇠를 당기거나 장전하면 탄창에 있는 탄환이 약실로 이동하는데, 이 때 약실로 이동한 탄환이 루프 상수에 해당합니다. 순회 대상이 포함하는 아이템을 차례로 넘겨받는 거죠. 장전이 끝나면 방아쇠를 당겨 탄환을 발사하는 것처럼 {} 블록 내 구문이 실행됩니다. 탄환이 발사되고 나면 다음 탄환이 다시 약실로 이동하듯이 순회 대상에 있는 다음 아이템도 루프 상수로 넘겨집니다. 모든 준비가 끝나면 다시 실행 되죠 이렇게 순회 대상에 포함된 모든 아이템이 고진됨녀 비로소 반복문의 실행이 완료됩니다.  실제 구문을 보면서 이해의 폭을 넓혀 봅시다. 다음은 범위 연산자를 순회 대상을 사용하여 for~in 구문을 작성한 예제입니다.
닫힌 범위 연산자로 작성된 범위 데이터 1...5는 [1,2,3,4,5]까지의 데이터를 순서대로 생성합니다. 이 값이 for~in 구문의 순회 대상이 되면 루프 상수인 row에는 최초에 1이 대입되고, 이어서 실행 블록 내의 구문이 실행됩니다. 현재 루프 블록 내의 구문은 단순이 루프 상수를 출력하는 print() 함수만 포함되어 있으므로 루프 상수의 값을 콘솔에 출력하고 턴을 마칠겁니다. 이어서 두 번째 반복이 시작되면 이번에는 루프 상수에 범위 데이터의 두 번째 값이 2가 대입되고, 실행 블록 내의 print()구문이 다시 루프 상수를 출력합니다.
순회 대상은 다 섯개의 아이템으로 이루어져 있으므로 총 다섯 번에 걸쳐 루프 상수의 출력 구문이 반복 실행됩니다. 이 같은 과정을 거쳐 예제가 실행된 결과는 다음과 같습니다.
for 반복문을 통해 좀 더 다양한 형식의 구문을 실행하는 것도 가능합니다. 반복문에서 빠지지 않는 예제가 바로 구구단이죠. 다음은 앞 예제를 응요하여 구구단 2단을 출력하는 예제입니다.
조금 다른 구문을 작성해 봅시다. 앱이나 웹에서 개인정보를 입력할 때, 태어난 연도를 선택하라는 화면을 본 적이 다들 있을 겁니다. 보통 1940년 정도 부터 현재까지 70~80개 이상의 연도를 출력해야 하는데, 이 때 에도 for 반복문을 사용하면 쉽게 이 값을 출력할 수 있습니다.
앞선 예제들에서 사용된 루프 상수 row, yeat등은 임의의 다른 상수명으로 변경해도 됩니다. C 기반의 문법을 사용하는 언어에서는 전통적으로 루프 상수에 i,k, j 등으 단일 문자를 사용하는 경향이 짙습니다. 단 상수이기 때무에 직접 값을 대입할 수는 없으며, 정의된 루프 상수는 for ~ in 구문의 실핼 블록 내부에서만 사용할 수 있습니다. 다시 말해 위 예제에서 정의한 year 변수를 for 블록 바깥에서 사용하려고 하면 오류가 발생한다는 뜻입니다. 루프 상수는 오직 for 블록 내에서만 사용할 수 있음을 기억하기 바랍니다.
이번에는 for ~in 구문을 이용하여 문자열으 문자를 순회하는 방법을 알아봅신다. String은 단일 객체롤 사용되지마느 그 구조를 들여다보면 Character 타입의 개별 문자들이 모여 이루어진 객체입니다. 이들 개별 문자는 순서를 이룬 채 연결되어 하나의 문자열을 구성하므로 이 역시 순회 대상으로 사용할 수 있습니다. 다만 String 타입 자체는 순회 처리를 지우너하지 않으므로 다음과 같이 chracters 속성을 사용해야 합니다.
루프 상수로 사용된 char는 루프 구문 내에서 자동으로 Character 타입으로 선언되어 "swift"라는 문자열의 각 문자를 받아드리는 역할을 합니다. 루프의 실행 횟수는 문자열의 크기만큼이므로 총 5회 반복됩니다.
루프 상수의 생략
for ~ in 구문을 사용할 때 루프 상수가 필요하지 않을 수도 있습니다. 순회 대상 자체보다는 단순히 순회 대상의 크기 만큼 반복하는 것이 목적인 경우죠. 이 때에는 _언더바를 사용하여 루프 상수를 생략할 수 있습니다. 다음을 봅시다.
size 값만큼 keyword 문자열의 왼쪽에 0을 채워 넣는 구문입니다. 주어진 값이 5까지 이므로 1부터 5까지 모두 5에 걸쳐 루프가 실행디며, 매 실행마다 왼쪽에 0이 추가됩니다. 실행 결과 모두 다섯개의 0이 추가된 문자열이 만들어졌습니다.
이 구문에서 루프상수는 굳이 필요하지 않습니다. 따라서 루프 상수가 있어야 할 자리를 언더바로 대신하였습니다. 이렇게 변수나 상수가 들어가야 할 자리를 언더바로 채우는 것은  스위프트에서 Wild card라고 합니다.
for~in 구문의 중첩
for~in 구문은 필요에 따라 중첩하여 사용할 수 있습니다.for~in구문 내에서 또 다른 for~in 구문을 작성하여 사용할 수 있다는 뜻이비낟. 이러한 형태를 흔히들 다중 루프라고 부르는데, 특히 두 개의 루프 구문이 중첩된 코드를 별도로 이중 루프라고 부릅니다. 이 용어들이 정식 명칭은 아니므로 이렇게 부으지 않으면 잘못된거에요 라고 생각하면 안됩니다. 어디까지나 현업에서 편의상 사용하는 국적 불명의 용어일 따름입니다. 
다중 루프를 효괒덕으로 사용하면 굉장히 시너지 효과를 낼 수 있지마, 반대로 코드의 해석을 난해하게 만드는 주범이 되기도 하므로 주읭해서 사용해야 합니다. 대부분의 프로그래밍 책에서 이중 루프를 설명할 때 빠디징 낳고 등장하는 구구단 1단 부터 9단까지를 작성
주석을 제외하면 단 세줄의 코드로 이루어진 예제입니다. 결과물에 비하면 코드는 무척 단순한데, 이 것이 바로 반복문으 힘이라 할 수 있죠. 이 예제는 바깥쪽 루프와 안쪽 르프로 이루어져 있습니다. 바깥쪽 루프는 1부터 9까지 차례대로 순회하고, 안쪽 루프 역시 1 부터 9까지 차례대로 순회합니다. 바깥쪽 루프가 순회할 때 마다 루프 상수 i에는 1부터 9까지 차례로 대입되고, 안쪽 루프가 순회 할 대 마다 루프 상수 j에도 1 부터 9까지의 정수가 차례로 대입됩니다.
바깥쪽 루프레서는 루프가 중첩되면 바깥쪽의 루프가 한 번 실행될 때 마다 안쪽의 루프는 매 번 모두 반복되기 때무에 전체 반복 횟수는 각 루프 실행 횟수를 곱한 만큼이 됩니다. 위 구구단 예제는 안쪽과 바깥쪽 모두 루프 상수가 1부터 9까지 변하므로 바깥쪽의 루프가 모두 9번 실행되고, 그때마다 안쪽의 루프가 9번씩 실행됩니다. 따라서 실행 회수는 안쪽과 바깥쪽의 반복 회수를 곱한 값인 9X9,즉 81번이 됩니다. 두 개의 루프가 중첩되었을 뿐이지만 벌서부터 해석하기 힘들어지는 독자들이 있을 겁니다. 만약 루플가 세 개, 네 개 이상 중첩된다면 코드는 거의 재앙(?)에 가까운 수준이 됩니다. 이 때문에 다중 루프를 사용할 때에는 최대한 간결하고 읽기 좋게 코드를 작성할 수 있도록 각별히 신경 써야 합니다
4.1.2 while 구문
앞에서 살펴본 for ~ in 구문은 미리 정의된 실행 횟수만큼만 반복하지만 while 구문은 단순히 주어진 조건식의 결과가 false가 될 때까지 실행 구문을 계속 반복 수행합니다. 다시 말해서 while 구문은 조건을 만족하는 동안은 계속 실행되는 것으로 이해하면 됩니다. 
for ~ in 구문과 비슷하게 코드를 반복하는 특성이 있기 때문에 종종 어떤 상황에서 무엇을 사용해야 하는 지 헷갈리는 분들이 많습니다. for ~ in 구문은 while 구문으로 쉽게 변경할 수 있지만 반대로  while 구문이 필요한 상황을 for~in 구문으로 처리하는 것은 쉽지 않기 때문에 while문을 사용해야 하는 상황만 정확하게 정리해두면 이해하기 좋습니다. while구문을 사용해야하는 경우는 다음과 같습니다.
* 실행 횟수가 명확하지 않을 때
* 직접 실행해보기 전까지는 실행 횟수를 결코 알 수 없을 때
* 실행 횟수를 기반으로 알 수 없는 조건일 때
while구문의 사용 형식은 다음과 같습니다.
```while <조건식> {
	<실행할 구문>
}```
while 키워드 다음에는 조건식이 사용되는데, 조건식은 반드시 참(true)이나 거짓(false)을 결과값으로 반환해야 합니다. 그래서 주로 비교 연산자가 사용되는 경우가 많죠 이 조건식의 값이 true인 동안은 실행 블록 내의 코드가 반복해서 수행되지만 false를 반환하면 그 즉시 반복문의 실행은 종료되고 코드 블록을 빠져나가 바로 다음에 이어지는 구문을 실행하게 됩니다.
이 예제는 초기에 주어진 값 n을 계속해서 2배씩 증가시키다가 1,000보다 커지는 순간 루프를 중지하는 예입니다. 조건문만 보단면 변수 n에 입력될 값을 미리 알 수 없는 상태입니다. 게다가 반복 실행할 기준이 횟수가 아니라 조건입니다. 정확히는 n의 값이 1000보다 작을 조건이죠 그러니 while 구문을 사용하기에 충분합니다. 만약 이 반복 조건을 for~in 구문으로 작성한다면 아마도 생각보다 복잡한 코드가 필요할 겁니다.
while 구문에 조건식 대신 true값을 직접 넣으면 한없이 반복 실행되는 무한 루프가 만들어질 겁니다. 코드 블록을 탈출할 수 있도록 break 문을 넣어주지 않는다면 이 프로그램을 프로세스가 종료하지 않는 한 영원히 실행 블록을 반복하게 될 겁니다.
대부분의 무한 반복되는 코드는 치명적인 문제가 되곤 하지만, 언제나 그런 것은 아닙니다. 터치나 클릭 등 사용자의 액션과 이벤트에 의해 동작하는 모바일 앱은 특성상 사용자의 액션을 기다리는 동안 입력 대시 상태를 유지하는데, 앱이 종료되지 않은 채로 대기 상태를 유지하기 위해 이벤트 루프라고 불리는 무한 루프를 만들어 실행합니다. 무한루프는 이론상 영우너히 반복되기 때문에 앱을 종료시키지 않고 유지할 수 있죠. 이 때 무한 루프를 만들기 위해 while 구문이 사용됩니다.
4.1.3 repeat ~ while 구문
repeat~while 반복문은 다른 언어에서 do~while 구문에 해당하는 것으로 스위프트 2.0 버전부터 새로 추가되었습니다. 정확히는 초기 버전의 스위프트에서 do~while 구문으로 발표되었던 것이 스위프트 2.0 버전에서 repeat~while 구문으로 변경되었죠. 기존에 사용되던 do~ while구문은 스위프트 2.0 버전에서 예외 처리구문으로 변경되었기 때문에, 그 대신 repeat~while 구문이 제공되기 시작한 겁니다.
```repeat {
	<실행할 구문>
}
while <조건식>
```
조건식을 먼저 평가하여 실행 블록의 수행 여부를 결정하는 while구문과 달리 repeat~ while 구문은 코드 믈록을 일단 실행항 다음에 조건식을 평가하여 반복 여부를 결정합니다. 이 것에 따라 repeat~while 구문응ㄴ 실행 블록의 수행을 최소 한 번을 보장하는 특성을 가지는데, 이것이 while 구문과의 결정적 차이점입니다. while 구문은 조건식을 먼저 평가하여 false가 반환되면 실행 블록을 아예 수행하지 않으니까요
앞서 학습한 while 구문입니다. 변수 n의 값을 1024로 입력한 다음에 반복문을 실행하면 주어진 조건식에는 n < 1000 조건을 만족하지 못하므로 false 가 됩니다. 따라서 n = n * 2 구문은 한 번도 실행되지 않은 상태롤 반복문이 종료되어 버리고 	n의 값은 아무런 변화 없이 처음 입력한 그대로 유지됩니다. 하지만 이를. repeat ~while 구문으로 처리하면 결과는 다릅니다.
같은 조건이지만, n의 최종값은 다릅니다. repeat~while 구문은 실행 블로기 한 번 수행 된 상태에서 조건식을 평가하므로 비로 조건식의 결과가 false라 할지라도 이미 n = n * 2 구문이 한 번 실행된 상태입니다. 따라서 n에 할당된 값은 2048이 됩니다.
이처럼. repeat~while구문은 while구문을 사용해야 하는 조건 중에서 반드시 한 번은 실행 할 필요가 있는 조건에 사용됩니다.
4.2.2 guard 구문
guard 구문은 if 구문과 마찬가지로 주어진 표현식의 결과가 참인지 거짓인지에 따라 구문 실행 여부를 결정짓는 방식의 조건문입니다. if구문과의 차이점은 guard구문에는 else블록이 필수이지만 표현식의 결과가 참일 때 실행되는 블록이 없다는 점입니다.
```guard <조건식 또는 표현식> else {
	<조건식 또는 표현식의 결과가 false일 때 실행될 코드>
}```
guard 구문은 주로 후속 코드들이 실행되기 전에 특정 조건을 만족하는 확인하는 용도로 사용합니다. 다시 말해 특정 조건을 만족하지 않은 채로 후속 코드를 실행하면 심각한 오류가 발생할 경우에 전체 구문은 조기 종료(Early Exit)하기 위한 목적으로 사용되는 것이 guard 구문입니다. 따라서 guard 구문의 else 블록에는 이후의 코드 진행을 막아주는 구문이 반드시 포함되어야 합니다. return 도는 break 구문이 이 같은 조기 종료 처리 역할을 합니다. 다음 예제를 봅시다.
아직 학습하지 않았지만, 위 예제는 함수를 정의하는 구문입니다. 여기서 함수란 값을 입력 받아 정해진 처리를 하도록 정의된 기능 단위를 말합니다. 주어진 예제에서는 divide하는 이름의 함수가 base 변수를 통해 입력받은 정수값으로 100을 나누고, 그 몫을 출려갛는 과정을 정의하고 있습니다.
이 함수에서 주의해야 할 부분은 입력받은 값을 이용하여 100을 나눈다는 점입니다. 나눗셈에서 주의할 아주 유명한 수학적 전제가 하나 있는데, 바로 어떤 숫자이든지 0으로 나누어서는 안된다는 겁니다. 이 점은 컴퓨터 연산에서도 마찬가지입니다. 0을 제외한 모든 값은 나눗셈 연산에 사용할 수 있지만, 0 으로 나눌 경우에는 오류가 발생합니다. 이를 'Divide By Zero' 오류라고 합니다. 따라서 입력받은 값이 0이 아닐 떼에만 함수 내의 코드를 실행하고, 그렇지 않을 경우에는 함수의 실행을 중지해야 합니다. 이런 경우를 제어하기 위해 다음과 같이 guard구문을 사용합니다.
함수의 실행을 종료할때에는 return 구문을 사용합니다. retur구문이 실행되면 이후의 코드가 남아있더라도 더 이상 진행하지 않은 채로 함수다 종료됩니다. 함수의 종료와 함께 반환해야 하는 값이 있다면 그 값을 반환하는 역할도 return 구문의 몫입니다.
divide 함수는 입력받은 인자값이 0이면 guard 구문의 조건을 만족하지 못합니다. 이 때에는 else 블록 내부에 작성된 return 구문이 실행되어 이후의 코드를 실행하지 않은 채로 종료됩니다. 아, 물론 연산을 처리할 수 없다는 메세지는 출력하겠지만요. 이후의 코드는 실행되지 않으므로 0으로 나누는 오류가 발생하지도 않습니다. 만약 인자값이 0이 아니라면 else 블록이 실행되지 않으니 guard 구문 이후의 코드가 실행되어 나누기 연산이 처리될 테고요.
앞에서 if 구문을 충분히 이해했다면 위 예제를 보고 if구문으로 대신할 수 있다는 생각을 할겁니다. 맞습니다. guard 구문은. if구문으로 대체할 수 있습니다.
주의할 점은, guard 구문 대신 if구문을 사용함으로 인해 조건식이 반대로 바뀐다는 것입니다. guard 구문에서는 나누기 연산을 위해 충족되어야 하는 조건을 사용했다면 if 구문에서는 반대로 연산이 실패할 조건을 사용하여 함수를 종료하도록 처리하고 있음에 유의해서 작성해야 합니다.
이처럼 guard 구문은 언뜻 보기에 if 구문으로 대체가 가능하기 때문에 그다지 필요 없어 보일 수도 있습니다. 하지만 guard 구문은 본래 실행 흐름을 종료하기 위한 목적으로 사용되는 구문이기 때문에, 코드를 중첩해서 사용하지 않아도 된다는 장점이있습니다. 이 점은 전체 코드를 굉장히 깔끔하고 단순하게 만들어줍니다. guard 구문을 많이 사용해도 코드의 깊이가 깊어지지 않기 때문입니다. 다음은 guard 구문을 이용하여 인자값을 다양한 조건으로 필터링하는 코드를 보여줍니다.
이런 특성 때문에, 조건을 체크하여 실행 흐름을 종료시킬 때에는 가급적 guard 구문을 사용하는 것이 좋습니다. 조건을 체크하되 다른 실행 흐름을 이어나가고 싶은 경우에만 if~else 구문을 사용하면 됩니다.
4.2.3 #available 구문
앱을 개발하다 보면 기기의 OS 버전별로 구문을 나누어  작성해야 할 때가 종종 있습니다. 사용하고자 하는 기능이 OS버전에 따라 다르게 제공되거나 하위 버전에서는 지원되지 않는 것이 가장 큰 원인인데요. 이를 보통 현업에서는 'API가 버전을 탄다'라고 표현하기도 합니다. 애프에서 제공하는 코코아 터치 프레임워크의 주요 API를 사용할 때에는 애플 개발자용 API 문서를 확인해서 사용 가능한 OS 버전과 기기를 체크해야 합니다.
그림은 아이폰이나 아이패드가 외부에서 URL 데이터를 요청하기 위해 사용할는 NSURLRequest 객체의 API 정보를 나타낸 문서 일부입니다. NSURLRequest는 주로 서버에서 웹 API를 호출하거나 웹 페이지를 읽어오기 위한 목적으로 파운데이션 프레임워크에서 제공하는 객체입니다. 이런 객체를 사용하는 방법 API라고 하는데, 그임의 문서는 현재 initWithURL이라는 메소드르르 사용하는 방법을 설명하고 있습니다. 나열된 여러 항목을 차례로 살펴보면 이 메소드를 스위프트와 오브젝티브-C 각각의 코드로 호출하는 예시 구문고 메소드를 호출할 때 사용해야 할 인자값, 메소드의 반환값 등에 대해 이어서 설명하고 있습니다.